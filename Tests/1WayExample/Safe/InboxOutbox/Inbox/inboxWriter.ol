from console import Console
from database import DatabaseInterface
from runtime import Runtime
from json-utils import JsonUtils
from reflection import Reflection
from time import Time

from ..publicInboxTypes import InboxConfig, InboxWriterExternalInterface
from .internalInboxTypes import KafkaMessage

from ...test.testTypes import ConsumerTestInterface

/** This interface is used by the MRS to call the InboxWriter when it finds a new message in Kafka */
interface InboxWriterKafkaInterface {               
    RequestResponse:
        /** This operation is called when some message is found in Kafka. It parses the message from Kafka into the parts 'operation', 'parameters' and 'mid'.
            It inserts the message into the inbox table, if a message with the same mid does not already exist */
        recieveKafka( KafkaMessage )( string )
}

/**
*   This service handles receiving messages, and inserting them into the 'inbox' table.
*       Inbox table:
*           ____________________________________________________________________________
*           |       operation      |       parameters      |   arrivedFromKafka  |  messageId  |
*           |——————————————————————|———————————————————————|—————————————————————|—————————————|
*           |     "startChor..."   |  {"username":"user1"} |           F         |    42       |
*           |——————————————————————|———————————————————————|—————————————————————|—————————————|
*           |     "finalizeChor"   |  {"username":"user3"} |           T         |    42       |
*           |——————————————————————|———————————————————————|—————————————————————|—————————————|
*/
service InboxWriterService (p: InboxConfig){
    execution: concurrent

    /** Used for MRS to talk with the inbox */
    inputPort InboxInput {
        Location: "local"
        Interfaces: 
            InboxWriterKafkaInterface
    }

    /** This port can be called by an embedder to manually insert a new message */
    inputPort ExternalInput {
        Location: "local"
        Interfaces: 
            InboxWriterExternalInterface, ConsumerTestInterface
    }

    /** Used to send messages to the Database Service */
    outputPort Database {
        Location: "local" // Overwritten in init
        Interfaces: DatabaseInterface
    }

    outputPort MRS {
        Location: "local"
        Interfaces: ConsumerTestInterface
    }

    embed Console as Console
    embed JsonUtils as JsonUtils
    embed Runtime as Runtime
    embed Time as Time

    init
    {
        Database.location = p.locations.databaseServiceLocation
        // This query uses a mix of arrivedFromKafka and mid, since we now need to recieve messages from outside Kafka as well.
        // If we used the unique constraint only on the mid, we might reach a situation where some ID generated by the 
        // Outbox of Service A was already assigned to some message that Service B had recieved from another source.
        // Another issue arrises if Service B recieves messages on different topics, but in such a case, it would
        // suffice to introduce the topic as a part of the unique constraint.
        update@Database( 
            "CREATE TABLE IF NOT EXISTS inbox (operation VARCHAR (150), parameters TEXT, arrivedFromKafka BOOL, messageId TEXT, handled BOOL, UNIQUE(arrivedFromKafka, messageId));" 
            )( ret )

        // This service handles inserting messages into the 'Inbox' table. Messages can be recieved from a socket location, or from Kafka.
        // Messages from Kafka are read by the MRS service, instantiated here. MRS will forward new messages from Kafka and int this service.
        getLocalLocation@Runtime(  )( locallocation )
        
        loadEmbeddedService@Runtime({
            filepath = "Inbox/messageRetrieverService.ol"
            params << {
                .pollTimer = p.pollTimer;
                .kafkaInboxOptions << p.kafkaOptions;
                .inboxWriterLocation << locallocation
            }
        })( MRS.location )
    }

    main{
        [insertIntoInbox( req )( res ){
            //println@Console("Inbox: Storing incomming message for operation " + req.operation)()
            scope( MakeIdempotent )
            {
                install( SQLException => res = "Problem inserting the message")

                getJsonString@JsonUtils( req.request )( inboxRequest )

                // If an Id is provided, we can assure exactly-once-delivery even at this step
                if ( req.request.id instanceof string )
                {
                    update@Database("INSERT INTO inbox (operation, parameters, arrivedFromKafka, messageId, handled) VALUES ('" + req.operation + "','" + inboxRequest + "', false, '" + req.id + "', false);")()
                } 
                else // req.request.id instanceof void
                {
                    getProcessId@Runtime( )( processId )
                    getCurrentTimeMillis@Time()( timeMillis )
                    messageId = processId + ":" + timeMillis
                    update@Database("INSERT INTO inbox (operation, parameters, arrivedFromKafka, messageId, handled) VALUES ('" + req.operation + "','" + inboxRequest + "', false, '" + messageId + "', false);")()
                }
            }
            res = "Message stored"
        }]

        [recieveKafka( req )( res ) 
        {
            if (global.testParams.throw_before_updating_inbox && !global.hasThrownAfterForMessage){
                global.hasThrownAfterForMessage = true
                throw ( TestException, "throw_before_updating_inbox" )
            }
            
            //println@Console("Inbox: Storing incomming message for operation " + req.key)()
            scope( MakeIdempotent )
            {
                install( SQLException => res = "Message already recieved" )

                getJsonValue@JsonUtils( req.value )( kafkaValue )

                // As per protocol, the key will be the operation, and the value a string containing the request. 
                update@Database("INSERT INTO inbox (operation, parameters, arrivedFromKafka, messageId, handled) VALUES ('" + req.key + "','" + kafkaValue.parameters + "', true, '" + kafkaValue.mid  + "', false);")()
                
                res = "Message stored"
            }

            if (global.testParams.throw_after_updating_inbox_but_before_response && !global.hasThrownAfterForMessage){
                global.hasThrownAfterForMessage = true
                throw ( TestException, "throw_after_updating_inbox_but_before_response" )
            }
        }]

        [setupConsumerTests(req)(res){
            global.testParams << request.inboxTests
            global.hasThrownAfterForMessage = false
            setupConsumerTests@MRS( request )( response )
        }]
    }
}